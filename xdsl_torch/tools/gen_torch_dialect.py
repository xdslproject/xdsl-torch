from typing import Any

import torch

TORCH_TYPE_TO_ODS_TYPE = {
    "Tensor": "AnyTensorTypeConstr",
}

preambule = """
###
# This dialect is automatically generated by tools/gen_torch_dialect.py
# Please don't edit it manually!
###
"""

imports = """
from xdsl.dialects.builtin import AnyTensorTypeConstr
from xdsl.irdl import IRDLOperation, irdl_op_definition, operand_def, result_def
"""


def format_name(name: str):
    # Format in a way consistent with torch-mlir
    if not name:
        return name

    new_name = name.title().replace("_", "")
    new_name = (
        ("_" if name[0] == "_" else "") + new_name + ("_" if name[-1] == "_" else "")
    )
    return new_name


def generate_class_def(ns: str, op_name: str, overload_name: str, schema: Any):
    full_op_name = f"torch.{ns}.{op_name}{'.' if overload_name else ''}{overload_name}"
    if "out" in full_op_name:
        # These are ops that store their results in a given argument-buffer
        # Should be delt with separately
        return None, None
    if full_op_name in [
        "torch.aten._linalg_slogdet.sign",
        "torch.aten._linalg_det.result",
    ]:
        # Ops have argument and return named the same way => we get an error
        return None, None

    class_name = (
        "Torch_" + ns.title() + format_name(op_name) + format_name(overload_name) + "Op"
    )

    # Parse arguments
    args_def: list[str] = []
    for arg in schema.arguments:
        type_name = str(arg.type)
        if type_name not in TORCH_TYPE_TO_ODS_TYPE:
            return None, None
        args_def.append(
            f"{arg.name} = operand_def({str(TORCH_TYPE_TO_ODS_TYPE[type_name])})"
        )

    # Parse outputs
    outputs_def: list[str] = []
    output_names = [out.name if out.name else "result" for out in schema.returns]
    if output_names.count("result") > 1:
        unnamed_idx = 0
        for i, name in enumerate(output_names):
            if name == "result":
                output_names[i] = f"result{unnamed_idx}"
                unnamed_idx += 1

    for i, out in enumerate(schema.returns):
        type_name = str(out.type)
        if type_name not in TORCH_TYPE_TO_ODS_TYPE:
            return None, None
        outputs_def.append(
            f"{output_names[i]} = result_def({str(TORCH_TYPE_TO_ODS_TYPE[type_name])})"
        )

    # Asm format
    args_asm = " `,` ".join([f"${arg.name}" for arg in schema.arguments])
    args_types_asm = " `,` ".join([f"type(${arg.name})" for arg in schema.arguments])
    outs_types_asm = " `,` ".join([f"type(${out_name})" for out_name in output_names])
    asm = (
        args_asm
        + " attr-dict `:` "
        + args_types_asm
        + (" `->` " + outs_types_asm if output_names else "")
    )

    curr_def = f"""
@irdl_op_definition
class {class_name}(IRDLOperation):
\tname = "{full_op_name}"
\t{"\n\t".join(args_def)}
\t{"\n\t".join(outputs_def)}
\tassembly_format = "{asm}"
    """

    return class_name, curr_def


def create_class_definitions():
    op_class_mapping: dict[str, str] = {}
    class_definitions = "\n"
    for ns in map(str, torch.ops):
        for op_name in getattr(torch.ops, ns):
            opoverloadpacket = getattr(getattr(torch.ops, ns), op_name)
            for overload_name, schema in opoverloadpacket._schemas.items():
                class_name, curr_def = generate_class_def(
                    ns, op_name, overload_name, schema
                )
                if curr_def and class_name:
                    class_definitions += curr_def + "\n"
                    op_class_mapping[
                        f"torch.ops.{ns}.{op_name}.\
                            {overload_name if overload_name else "default"}"
                    ] = class_name
    return class_definitions, op_class_mapping


def create_op_class_mapping_file(op_class_mapping: dict[str, str]):
    imports = """
from typing import Dict, Any
import torch
from xdsl_torch.dialects.torch_ops_generated import *
    """
    mapping = (
        "XDSL_TORCH_OPS: Dict[Any, type] = {"
        + "\n\t".join(
            [
                f"{torch_class}: {xdsl_class},  # type: ignore"
                for torch_class, xdsl_class in op_class_mapping.items()
            ]
        )
        + "\n}"
    )
    return "\n".join([preambule, imports, mapping])


class_definitions, op_class_mapping = create_class_definitions()

full_content = "\n".join([preambule, imports, class_definitions])
with open("xdsl_torch/dialects/torch_ops_generated.py", "w+") as f:
    f.writelines(full_content)

with open("xdsl_torch/dialects/torch_mapping.py", "w+") as f:
    f.writelines(create_op_class_mapping_file(op_class_mapping))
